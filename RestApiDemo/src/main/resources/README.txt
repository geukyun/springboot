07.26
4.2.5 트랜잭션 처리
    DB에서 키가 동일하다면 동일한 정보로 간주해 생성을 허용하지 않아야 한다.
    이를 위해 ddl-auto를 설정 - ddl-auto에는 여러개의 설정이 있다.
     - create: 애플리케이션 실행시점에 기존 테이블들을 모두 삭제하고, 다시 생성한다.
     - create-drop: 애플리케이션 종료시점에 기존 테이블들을 모두 삭제하고, 다시 생성한다.
     - update: 애플리케이션 실행시점에 ‘JPA 엔티티 설계’와 ‘실제 테이블 상태’를 비교하여, 실제 테이블에서 변경된 부분만 반영한다.
     - validates: 애플리케이션 실행시점에 엔티티와 테이블이 정상 매핑 되었는지만 확인한다.
     - none: 사실상 아무 설정도 하지 않은거지만 명시적으로 확인하기 위해서 사용한다.
    ddl-auto를 설정했다면, 모델 엔티티 속성에 @Column(unique=true)를 추가해 테이블을 생성할 때 컬럼에 UNQIUE 속성을 갖도록 한다.

07.31
4.4 웹 필터
    4.4.1 로그 필터 작성
     - 로그 필터는 Controller 앞 단에 위치해 클라이언트가 요청한 URI 정보를 로그로 출력하고,
       해당 요청을 수행하는 데 걸리는 시간도 함께 로그로 출력
       스프링 부트 애플리케이션에서 웹 필터를 만드는 것은 간단합니다. 클래스에 @WebFilter를 추가하고 Filter 인터페이스를 구현하면 된다.
       @WebFilter에는 필터를 적용할 URL 패턴을 지정하면 된다.
         ** @WebFilter(urlPattern = "/api/*")
         ** 필터를 적용할 URL 패턴이 여러개라면 {}로 감싸서 나열 @WebFilter(urlPattern = {"/api/*", "/admin/*"})
       클라이언트의 HTTP 요청은 컨트롤러에 도착하기 전에 필터들을 거치게 된다.
       필터의 doFilter()에서 요청 시 처리해야 할 일을 수행한 후에 다음 필터의 doFilter()를 호출하는 방식으로 동작하는데,
       이를 필터 체인이라고 함.
       필터의 doFilter() 메서드에는 클라이언트가 요청한 정보를 담고 있는 ServletRequest,
       이와 반대로 클라이언트로 응답하는 정보를 담고 있는 ServletResponse, 연결된 다음 필터들의 정보를 담고 있는 FilterChain이라는 세가지 파라미터가 전달.
         ** @WebFilter가 존재하는 클래스는 @SpringBootApplication과 동일한 패키지에 존재해야 한다.

    4.4.2 액세스 키 필터
     - 4.4.2 이전까지 구현한 RESTful API는 URL만 알게 되면 누구나 API를 호출해 회원 정보를 생성하거나
       혹은 특정한 회원이 작성한 게시글들을 조회할 수 있다.
       허가받은 클라이언트만 사용하도록 하려면 어떻게 해야 할까? RESTful API 형태로 OpenAPI를 제공하는 구글, 네이버, 카카오와 같은
       다수의 플랫폼 업체에서는 허가받은 클라이언트만 API를 호출할 수 있도록 액세스 키를 발금해 API를 호출할 때 HTTP 헤더를 통해 액세스 키를 함께 전송하도록 하고 있다.
     - 스프링 부트에서 제공하는 필터 기능을 사용하면 HTTP 해더에 포함된 액세서 키를 컨트롤러 앞단에서 검증할 수 있다.
       즉, 액세스 키를 검증하는 필터를 작성해 컨트롤러 앞 단에 배치함으로써 정상적인 액세스 키가 포함된 API 호출에 대해서만 컨트롤러에게 전달하고,
       액세스 키가 헤더에 포함되어 있지 않거나 액세스 키가 정상이 아닌 겨우에는 필터에서 바로 클라이언트로 401 Unauthorized 오류를 반환하도록 구현하면 된다.
     - 웹 필터는 일반적으로 OncePerRequestFilter를 상속받아 작성하는데, 그 이름에서 알 수 있듯이 한번의 요청에 대해 한 번만 필터를 거치도록 한다.
     - OncePerRequestFilter는 한 번 수행한 필터는 내부적으로 체크해 두었다가, 그 이후로는 건너뛰도록 함으로써 클라이언트의 요청 한 번에 대해 오직 한번만 필터를 거치도록 한다.
     - 실제 구현에서는 OncePerRequestFilter를 상속받았으므로, 필터는 doFilterInternal()을 오보라이드해 작성한다.
       전달된 HttpServletRequest 파라미터에서 Authorization 헤더를 구한 후 Bearer를 제거한 액세스 키가 '"'hanbit-access-key'인지 검증한 다음,
       정상적인 경우에는 다음 단계로 진행하고 그렇지 않은 경우에는 바로 인증 오류 401 Unauthorized를 반환하도록 구현한다.

    4.4.3 필터 등록 설정
      - @WebFilter가 사용된 필터가 여러 개인 경우라면 어떤 순서로 필터를 거치게 될까?
        기본적으로 필터는 알파벳순으로 거치게 된다.
      - 만약 필터들의 순서를 원하는 대로 배치하는 등의 상세한 제어를 원한다면 별도로 설정할 수 있다.
        우선 @ServletComponentScan과 @WebFilter 같은 애노테이션을 모두 삭제하고, 대신 필터 설정을 위한 @Configuration 클래스를 작성한다.
        그리고 @Bean을 사용해 로그 필터와 액세스 키 필터를 등록하기 위한 FilterRegistrationBean을 각각 생성한다.
        FilterRegistrationBean 클래스의 addUrlPattern()과 setOrder()를 사용하면 필터가 처리해야 할 URL 패턴뿐 아니라 필터의 순서도 정할 수 있다.
      - 프로젝트 소스 폴더에 config 폴더를 만들고 다음과 같이 FilterConfig.java를 작성한다. 여기서는 LogFilter의 순서 값을 1로 하고,
        AccessKeyFilter의 순서 값을 2로 한다. 따라서 로그 필터가 먼저 실행되고 난 후 액세스 키 필터를 거치게 된다.